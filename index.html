<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>MP3 Auto Quality Reducer</title>
<style>
body {
    background:#0e0e0e;
    color:#fff;
    font-family:Arial, sans-serif;
    text-align:center;
    padding:20px;
}
.box {
    background:#1b1b1b;
    padding:20px;
    border-radius:12px;
    display:inline-block;
    width:420px;
}
button {
    padding:12px;
    margin:6px;
    background:#4caf50;
    border:none;
    border-radius:6px;
    cursor:pointer;
    color:#fff;
    font-weight:bold;
}
button:hover { background:#66bb6a; }
input[type=range], input[type=number] { width:100%; }
hr { border:1px solid #333; }
</style>
</head>
<body>

<h1>üéß MP3 Quality Reducer</h1>
<p>AUTO mode ‚Äî trims only if you want</p>

<div class="box">
<input type="file" id="fileInput" accept="audio/*"><br><br>

<button onclick="applyAuto()">‚öôÔ∏è AUTO</button>

<hr>

<label>Start Time (seconds ‚Äî optional)</label>
<input type="number" id="startTime" placeholder="0">

<label>End Time (seconds ‚Äî optional)</label>
<input type="number" id="endTime" placeholder="Full length">

<hr>

<label>Sample Rate: <span id="srVal"></span> Hz</label>
<input type="range" min="4000" max="44100" id="sampleRate">

<label>Bit Depth: <span id="bdVal"></span></label>
<input type="range" min="2" max="16" id="bitDepth">

<label>Distortion: <span id="distVal"></span></label>
<input type="range" min="0" max="100" id="distortion">

<br><br>
<button onclick="processAudio()">üéõÔ∏è Process Audio</button>
</div>

<br><br>
<audio id="output" controls></audio><br>
<a id="download" download="processed.wav">Download</a>

<script>
const sr = sampleRate, bd = bitDepth, dist = distortion;
let lastURL = null;

function updateLabels(){
    srVal.textContent = sr.value;
    bdVal.textContent = bd.value;
    distVal.textContent = dist.value;
}
[sr,bd,dist].forEach(x => x.oninput = updateLabels);

function applyAuto(){
    sr.value = 22050;
    bd.value = 10;
    dist.value = 5;
    updateLabels();
}
applyAuto();

async function processAudio(){
    const file = fileInput.files[0];
    if(!file) return alert("Upload an audio file first");

    if(lastURL) URL.revokeObjectURL(lastURL);

    const ctx = new AudioContext();
    const buffer = await ctx.decodeAudioData(await file.arrayBuffer());

    // Fallback logic
    const startVal = startTime.value.trim();
    const endVal = endTime.value.trim();

    const start = startVal === "" ? 0 : Math.max(0, parseFloat(startVal));
    const end = endVal === "" ? buffer.duration : Math.min(buffer.duration, parseFloat(endVal));

    if(end <= start) return alert("End time must be greater than start time");

    const startSample = Math.floor(start * buffer.sampleRate);
    const endSample = Math.floor(end * buffer.sampleRate);
    const length = endSample - startSample;

    const trimmed = ctx.createBuffer(
        buffer.numberOfChannels,
        length,
        buffer.sampleRate
    );

    for(let ch=0; ch<buffer.numberOfChannels; ch++){
        trimmed.getChannelData(ch).set(
            buffer.getChannelData(ch).slice(startSample, endSample)
        );
    }

    const offline = new OfflineAudioContext(
        trimmed.numberOfChannels,
        Math.floor(length * (sr.value / buffer.sampleRate)),
        sr.value
    );

    const src = offline.createBufferSource();
    src.buffer = trimmed;

    const shaper = offline.createWaveShaper();
    shaper.curve = makeDistortionCurve(dist.value);

    src.connect(shaper);
    shaper.connect(offline.destination);
    src.start();

    const rendered = await offline.startRendering();
    bitCrush(rendered, bd.value);

    const blob = bufferToWave(rendered);
    lastURL = URL.createObjectURL(blob);

    output.src = lastURL;
    download.href = lastURL;
}

function makeDistortionCurve(a){
    const n=44100, curve=new Float32Array(n), k=a*8;
    for(let i=0;i<n;i++){
        const x=i*2/n-1;
        curve[i]=Math.tanh(x*k);
    }
    return curve;
}

function bitCrush(buf,bits){
    const step=Math.pow(0.5,bits);
    for(let c=0;c<buf.numberOfChannels;c++){
        const d=buf.getChannelData(c);
        for(let i=0;i<d.length;i++)
            d[i]=Math.round(d[i]/step)*step;
    }
}

function bufferToWave(buf){
    const len=buf.length*buf.numberOfChannels*2+44;
    const view=new DataView(new ArrayBuffer(len));
    let o=0;
    const w=s=>{for(let i=0;i<s.length;i++)view.setUint8(o++,s.charCodeAt(i));};

    w("RIFF"); view.setUint32(o,len-8,true); o+=4;
    w("WAVEfmt "); view.setUint32(o,16,true); o+=4;
    view.setUint16(o,1,true); o+=2;
    view.setUint16(o,buf.numberOfChannels,true); o+=2;
    view.setUint32(o,buf.sampleRate,true); o+=4;
    view.setUint32(o,buf.sampleRate*2,true); o+=4;
    view.setUint16(o,buf.numberOfChannels*2,true); o+=2;
    view.setUint16(o,16,true); o+=2;
    w("data"); view.setUint32(o,len-o-4,true); o+=4;

    for(let i=0;i<buf.length;i++){
        for(let c=0;c<buf.numberOfChannels;c++){
            let s=Math.max(-1,Math.min(1,buf.getChannelData(c)[i]));
            view.setInt16(o,s*0x7fff,true); o+=2;
        }
    }
    return new Blob([view],{type:"audio/wav"});
}
</script>

</body>
</html>
