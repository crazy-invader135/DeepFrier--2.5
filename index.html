<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>MP3 Deepfryer</title>
<style>
    body {
        background: #0e0e0e;
        color: #fff;
        font-family: Arial, sans-serif;
        text-align: center;
        padding: 20px;
    }
    .box {
        background: #1b1b1b;
        padding: 20px;
        border-radius: 12px;
        display: inline-block;
        max-width: 420px;
    }
    button {
        padding: 10px;
        margin: 5px;
        background: #ff4444;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        color: #fff;
    }
    button:hover {
        background: #ff6666;
    }
    input[type=range] {
        width: 100%;
    }
    .preset {
        background: #333;
    }
</style>
</head>
<body>

<h1>ðŸ”¥ MP3 Deepfryer ðŸ”¥</h1>
<p>Click a preset or tweak sliders</p>

<div class="box">
    <input type="file" id="fileInput" accept="audio/*"><br><br>

    <b>Presets</b><br>
    <button class="preset" onclick="setPreset('mild')">ðŸ™‚ Mild Fry</button>
    <button class="preset" onclick="setPreset('crunchy')">ðŸ˜ˆ Crunchy</button>
    <button class="preset" onclick="setPreset('deep')">ðŸ’€ Deepfried</button>
    <button class="preset" onclick="setPreset('earrape')">ðŸ‘¹ Earrape</button>

    <hr>

    <label>Sample Rate: <span id="srVal"></span> Hz</label>
    <input type="range" min="4000" max="44100" id="sampleRate">

    <label>Bit Depth: <span id="bdVal"></span></label>
    <input type="range" min="2" max="16" id="bitDepth">

    <label>Distortion: <span id="distVal"></span></label>
    <input type="range" min="0" max="100" id="distortion">

    <br><br>
    <button onclick="processAudio()">ðŸ”¥ Deepfry</button>
</div>

<br><br>
<audio id="output" controls></audio><br>
<a id="download" download="deepfried.wav">Download</a>

<script>
const sr = document.getElementById("sampleRate");
const bd = document.getElementById("bitDepth");
const dist = document.getElementById("distortion");

function updateLabels() {
    srVal.textContent = sr.value;
    bdVal.textContent = bd.value;
    distVal.textContent = dist.value;
}

[sr, bd, dist].forEach(sl => sl.oninput = updateLabels);

function setPreset(p) {
    if (p === "mild") {
        sr.value = 22050;
        bd.value = 10;
        dist.value = 5;
    }
    if (p === "crunchy") {
        sr.value = 11025;
        bd.value = 6;
        dist.value = 25;
    }
    if (p === "deep") {
        sr.value = 8000;
        bd.value = 4;
        dist.value = 50;
    }
    if (p === "earrape") {
        sr.value = 4000;
        bd.value = 2;
        dist.value = 100;
    }
    updateLabels();
}

setPreset("deep");

async function processAudio() {
    const file = fileInput.files[0];
    if (!file) return alert("Upload an audio file first!");

    const audioCtx = new AudioContext();
    const buffer = await audioCtx.decodeAudioData(await file.arrayBuffer());

    const offline = new OfflineAudioContext(
        buffer.numberOfChannels,
        buffer.length,
        sr.value
    );

    const source = offline.createBufferSource();
    source.buffer = buffer;

    const shaper = offline.createWaveShaper();
    shaper.curve = makeDistortionCurve(dist.value);

    source.connect(shaper);
    shaper.connect(offline.destination);
    source.start();

    const rendered = await offline.startRendering();
    const crushed = bitCrush(rendered, bd.value);

    const blob = bufferToWave(crushed);
    const url = URL.createObjectURL(blob);

    output.src = url;
    download.href = url;
}

function makeDistortionCurve(amount) {
    const n = 44100;
    const curve = new Float32Array(n);
    const k = amount * 8;
    for (let i = 0; i < n; i++) {
        const x = (i * 2) / n - 1;
        curve[i] = Math.tanh(x * k);
    }
    return curve;
}

function bitCrush(buffer, bits) {
    const step = Math.pow(0.5, bits);
    for (let ch = 0; ch < buffer.numberOfChannels; ch++) {
        const data = buffer.getChannelData(ch);
        for (let i = 0; i < data.length; i++) {
            data[i] = Math.round(data[i] / step) * step;
        }
    }
    return buffer;
}

function bufferToWave(buffer) {
    const length = buffer.length * buffer.numberOfChannels * 2 + 44;
    const view = new DataView(new ArrayBuffer(length));
    let offset = 0;

    function write(s) {
        for (let i = 0; i < s.length; i++) view.setUint8(offset++, s.charCodeAt(i));
    }

    write("RIFF");
    view.setUint32(offset, length - 8, true); offset += 4;
    write("WAVEfmt ");
    view.setUint32(offset, 16, true); offset += 4;
    view.setUint16(offset, 1, true); offset += 2;
    view.setUint16(offset, buffer.numberOfChannels, true); offset += 2;
    view.setUint32(offset, buffer.sampleRate, true); offset += 4;
    view.setUint32(offset, buffer.sampleRate * 2, true); offset += 4;
    view.setUint16(offset, buffer.numberOfChannels * 2, true); offset += 2;
    view.setUint16(offset, 16, true); offset += 2;
    write("data");
    view.setUint32(offset, length - offset - 4, true); offset += 4;

    for (let i = 0; i < buffer.length; i++) {
        for (let ch = 0; ch < buffer.numberOfChannels; ch++) {
            let s = buffer.getChannelData(ch)[i];
            s = Math.max(-1, Math.min(1, s));
            view.setInt16(offset, s * 0x7fff, true);
            offset += 2;
        }
    }
    return new Blob([view], { type: "audio/wav" });
}
</script>

</body>
</html>
