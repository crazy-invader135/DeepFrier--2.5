<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>MP3 Deepfryer</title>
<style>
body {
    background:#0e0e0e;
    color:#fff;
    font-family:Arial;
    text-align:center;
    padding:20px;
}
.box {
    background:#1b1b1b;
    padding:20px;
    border-radius:12px;
    display:inline-block;
    width:420px;
}
button {
    padding:10px;
    margin:4px;
    background:#ff4444;
    border:none;
    border-radius:6px;
    cursor:pointer;
    color:#fff;
}
button:hover { background:#ff6666; }
input[type=range], input[type=number] { width:100%; }
.preset { background:#333; }
</style>
</head>
<body>

<h1>ðŸ”¥ MP3 Deepfryer ðŸ”¥</h1>
<p>Presets + Trim + No Length Bugs</p>

<div class="box">
<input type="file" id="fileInput" accept="audio/*"><br><br>

<b>Presets</b><br>
<button class="preset" onclick="setPreset('mild')">ðŸ™‚ Mild</button>
<button class="preset" onclick="setPreset('crunchy')">ðŸ˜ˆ Crunchy</button>
<button class="preset" onclick="setPreset('deep')">ðŸ’€ Deepfried</button>
<button class="preset" onclick="setPreset('earrape')">ðŸ‘¹ Earrape</button>

<hr>

<label>Start Time (seconds)</label>
<input type="number" id="startTime" value="0" min="0" step="0.1">

<label>End Time (seconds)</label>
<input type="number" id="endTime" value="5" min="0" step="0.1">

<hr>

<label>Sample Rate: <span id="srVal"></span> Hz</label>
<input type="range" min="4000" max="44100" id="sampleRate">

<label>Bit Depth: <span id="bdVal"></span></label>
<input type="range" min="2" max="16" id="bitDepth">

<label>Distortion: <span id="distVal"></span></label>
<input type="range" min="0" max="100" id="distortion">

<br><br>
<button onclick="processAudio()">ðŸ”¥ Deepfry</button>
</div>

<br><br>
<audio id="output" controls></audio><br>
<a id="download" download="deepfried.wav">Download</a>

<script>
const sr = sampleRate, bd = bitDepth, dist = distortion;
let lastURL = null;

function updateLabels() {
    srVal.textContent = sr.value;
    bdVal.textContent = bd.value;
    distVal.textContent = dist.value;
}
[sr,bd,dist].forEach(x => x.oninput = updateLabels);

function setPreset(p){
    if(p==="mild"){ sr.value=22050; bd.value=10; dist.value=5; }
    if(p==="crunchy"){ sr.value=11025; bd.value=6; dist.value=25; }
    if(p==="deep"){ sr.value=8000; bd.value=4; dist.value=50; }
    if(p==="earrape"){ sr.value=4000; bd.value=2; dist.value=100; }
    updateLabels();
}
setPreset("deep");

async function processAudio(){
    const file = fileInput.files[0];
    if(!file) return alert("Upload audio first");

    if(lastURL) URL.revokeObjectURL(lastURL);

    const ctx = new AudioContext();
    const buffer = await ctx.decodeAudioData(await file.arrayBuffer());

    const start = Math.max(0, parseFloat(startTime.value));
    const end = Math.min(buffer.duration, parseFloat(endTime.value));

    if(end <= start) return alert("End time must be greater than start time");

    const startSample = Math.floor(start * buffer.sampleRate);
    const endSample = Math.floor(end * buffer.sampleRate);
    const length = endSample - startSample;

    const trimmed = ctx.createBuffer(
        buffer.numberOfChannels,
        length,
        buffer.sampleRate
    );

    for(let ch=0; ch<buffer.numberOfChannels; ch++){
        trimmed.getChannelData(ch).set(
            buffer.getChannelData(ch).slice(startSample, endSample)
        );
    }

    const offline = new OfflineAudioContext(
        trimmed.numberOfChannels,
        Math.floor(length * (sr.value / buffer.sampleRate)),
        sr.value
    );

    const src = offline.createBufferSource();
    src.buffer = trimmed;

    const shaper = offline.createWaveShaper();
    shaper.curve = makeDistortionCurve(dist.value);

    src.connect(shaper);
    shaper.connect(offline.destination);
    src.start();

    const rendered = await offline.startRendering();
    bitCrush(rendered, bd.value);

    const blob = bufferToWave(rendered);
    lastURL = URL.createObjectURL(blob);

    output.src = lastURL;
    download.href = lastURL;
}

function makeDistortionCurve(a){
    const n=44100, curve=new Float32Array(n), k=a*8;
    for(let i=0;i<n;i++){
        const x=i*2/n-1;
        curve[i]=Math.tanh(x*k);
    }
    return curve;
}

function bitCrush(buf,bits){
    const step=Math.pow(0.5,bits);
    for(let c=0;c<buf.numberOfChannels;c++){
        const d=buf.getChannelData(c);
        for(let i=0;i<d.length;i++)
            d[i]=Math.round(d[i]/step)*step;
    }
}

function bufferToWave(buf){
    const len=buf.length*buf.numberOfChannels*2+44;
    const view=new DataView(new ArrayBuffer(len));
    let o=0;
    const w=s=>{for(let i=0;i<s.length;i++)view.setUint8(o++,s.charCodeAt(i));};

    w("RIFF"); view.setUint32(o,len-8,true); o+=4;
    w("WAVEfmt "); view.setUint32(o,16,true); o+=4;
    view.setUint16(o,1,true); o+=2;
    view.setUint16(o,buf.numberOfChannels,true); o+=2;
    view.setUint32(o,buf.sampleRate,true); o+=4;
    view.setUint32(o,buf.sampleRate*2,true); o+=4;
    view.setUint16(o,buf.numberOfChannels*2,true); o+=2;
    view.setUint16(o,16,true); o+=2;
    w("data"); view.setUint32(o,len-o-4,true); o+=4;

    for(let i=0;i<buf.length;i++){
        for(let c=0;c<buf.numberOfChannels;c++){
            let s=Math.max(-1,Math.min(1,buf.getChannelData(c)[i]));
            view.setInt16(o,s*0x7fff,true); o+=2;
        }
    }
    return new Blob([view],{type:"audio/wav"});
}
</script>

</body>
</html>
